<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 自定义 zsh 自动补全功能初探 · Bhe's Blog</title><meta name="description" content="自定义 zsh 自动补全功能初探 - Bhe Hongtyu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://hitsmaxft.github.io/atom.xml" title="Bhe's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Bhe's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/hitsmaxft" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/hitsmaxft" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">自定义 zsh 自动补全功能初探</h1><div class="post-info">Mar 17, 2014</div><div class="post-content"><p>zsh 已经不是什么新鲜事了, <code>oh-my-zsh</code> 相信很多人都已经在用了.</p>
<p>但<code>zsh</code> 存在一个明显的问题, 它并不是什么开箱即用的工具, 需要大量配置, 也很难上手扩充新功能, 这点和vim非常相似.</p>
<p>常用的 alias 和 shell script, 虽然能用上些稍微方便的特殊语法, 大部分仍和 bash 相近. 这时候倒不如使用bash的语法, 保证代码的兼容性和可移植性.</p>
<p>本文简单介绍如何编写zsh的补全插件, 以 Mac OS 的 launchctl 为例.</p>
<pre><code>`launchctl` 是 Mac 用于管理系统运行, 类似于 linux 的 systemd, 用于管理 LaunchAgent 加载, 是 `launchd` 的前端.
</code></pre>
<p>常用的 subcommand 有 unload, load, stop ,start 等等. 这里就只考虑 load 和 unload 补全功能扩充.</p>
<h2 id="怎么开发脚本"><a href="#怎么开发脚本" class="headerlink" title="怎么开发脚本"></a>怎么开发脚本</h2><p>按作者的话说, 看文档是很难学会的. 因为很少涉及脚本编写本身, 仅罗列了所有的接口.</p>
<h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>首先将脚本命名为 <code>_launchctl</code> , 放到任意目录下, 让将目录加入 fpath</p>
<pre><code>oh-my-zsh 用户保存在 ~/.oh-my-zsh/plugins/launchctl/_launchctl.
并在 zshrc 中声明 plugins=( launchctl )
剩下的事情就交给 oh-my-zsh
</code></pre>
<p>脚本头部加上以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#compdef launchctl</span></span><br></pre></td></tr></table></figure>

<p>第一行标记这个文件包含一个自动加载的函数.<br>本质上这是一个没有形如 <code>function () &#123;&#125;</code> 包裹着的函数体,<br>和可以直接通过 <code>source</code> 导入的配置文件和脚本是不同的.</p>
<h2 id="subcommand-补全"><a href="#subcommand-补全" class="headerlink" title="subcommand 补全"></a>subcommand 补全</h2><p>subcommand 应该是子命令或者副命令的意思， 这里保留原文。</p>
<pre><code>ps: 对于 gnu 风格的命令行工具, 很少有 subcommand , 这一章节并不是必要的.
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">local -a _1st_arguments</span><br><span class="line"></span><br><span class="line">_1st_arguments=(</span><br><span class="line">    &quot;load:Load configuration files and/or directories&quot;</span><br><span class="line">    &quot;unload:Unload configuration files and/or directories&quot;</span><br><span class="line">    &quot;start:Start specified job&quot;</span><br><span class="line">    &quot;stop:Stop specified job&quot;</span><br><span class="line">    &quot;help:This help output&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">local label_subcommand=&quot;launchctl subcommand&quot;</span><br><span class="line"></span><br><span class="line">if (( CURRENT == 2 )); then</span><br><span class="line">    _describe -t commands &quot;$label_subcommand&quot; _1st_arguments</span><br><span class="line">    return 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这段代码还是比较好懂的, 补全所有的<code>subcommand</code>并给出提示信息.</p>
<p>注意 <code>CURRENT</code> 这个变量, 它标记处于命令行的第几个单词</p>
<pre><code>关于 CURRENT , 见 `man zshcompwid`
</code></pre>
<p>在按下tab之前, 用户输入的文本为 <code>launchctl&lt;空格&gt;&lt;tab&gt;</code>, 第一个单词是主命令<code>launchctl</code>, 显然在这段脚本中, <code>CURRENT</code> 是一个大于2的整数.</p>
<p>对于还存在更下一级 subcommand 的补全, 以此类推.</p>
<h2 id="文件补全"><a href="#文件补全" class="headerlink" title="文件补全"></a>文件补全</h2><p><code>launchctl unload</code> 用于关闭一个正在运行的服务, 比如nginx, php-fpm等等, 显然这里需要补全的是一个文件路径, 对应一个位于 <code>~/Library/LaunchAgents/</code> 下的 <code>plist</code> 文件.</p>
<p>首先假设已经实现了对应的工具函数 <code>_get_loaded_user_plists</code> , 这个函数将生成目前正在运行的plist文件列表</p>
<p>以下是关键代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">local</span> expl</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$words</span>[2]&quot;</span> <span class="keyword">in</span> </span><br><span class="line">    unload)</span><br><span class="line">        <span class="built_in">local</span> loaded_user_plists</span><br><span class="line">        loaded_user_plists=<span class="string">&quot;<span class="subst">$(_get_loaded_user_plists)</span>&quot;</span></span><br><span class="line">        _wanted loaded_user_plists expl <span class="string">&#x27;running jobs&#x27;</span> compadd -a loaded_user_plists</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 1</span><br></pre></td></tr></table></figure>

<p>可见对于简单参数的补全实现是很轻松的</p>
<p>zsh 如果发现补全函数返回0, 会将输出作为补全内容作为候补内容输出到终端中去.</p>
<p>因此我们只需要确定 subcommand 是我们所预期的<code>unload</code> , 将文件列表发送给用户就行了.</p>
<p>这里用<code>case</code> 根据 subcommand 的不同, 选择对应的补全形式.</p>
<p>首先注意 <code>$words</code> 这个变量, 通过打印该变量可以发现, 它是一个将用户已经输出的命令拆分的数组</p>
<p>比如输入 <code>launchctl unload</code> , 那么对应的words将是 <code>( &#39;launchctl&#39; &#39;unload&#39; &#39;&#39; )</code>, 最后一位是一个空字符串.</p>
<pre><code>严格地说, 这里拆分依据并不是空格
如果你明白 $@ 和 $# 区别, 你就懂我啥意思了. 
这里空间不够, 我就不写了 :)
</code></pre>
<h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><p>开发过程中难免写错, 需要重复调试, 这里有两个小技巧.</p>
<ol>
<li>echo</li>
</ol>
<p>echo 当然是喜闻乐见的 debug 指令之一了.</p>
<ol start="2">
<li>set -x</li>
</ol>
<p><code>set -x</code> 将开启zsh的 XTRACE 选项, 所有运行脚本背后的指令和参数都直接打印到屏幕, 俗称上帝视角.<br>如果发现不能正常执行, 那么只要运行 <code>set -x</code>, 手动输入命令后按tab. </p>
<blockquote>
<p>ps1: set +x 恢复正常模式.<br>ps2: 千万不要手残提前触发其他zsh的特性, 不然面对满屏的文本里就没啥心情继续下去了. 这里需要老老实实输入完整的命令, 在需要触发对应补全过程的地方按下tab触发补全.</p>
</blockquote>
<p>由于调试信息实在太多了, 运行几次之后可以把调试窗口关了, 或者将终端的buffer清空, 总而言之, 减少输出的log以快速定位问题.</p>
<pre><code>至于更细节的内容以及相关api文档, 请看手册 `man zshcompsys`
zsh 的~~破手册~~跟天书一样的文档也没打算解释清楚, 我能说的只有这么多了
更多技术细节请自行深挖.
</code></pre>
<p>Job done!</p>
</div></article></div></main><footer><div class="paginator"><a href="/2014/03/23/introduction-to-vim/" class="prev">PREV</a><a href="/2014/03/07/classmap-generating-by-composer/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://hitsmaxft.github.io">Bhe Hongtyu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>